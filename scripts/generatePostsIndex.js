#!/usr/bin/env node
/*
  Simple generator: scans public/posts/*.md, parses YAML frontmatter (if present),
  and writes src/posts/postsIndex.js exporting an array of posts.

  Usage: node scripts/generatePostsIndex.js
*/
const fs = require('fs');
const path = require('path');
const yaml = require('js-yaml');

const POSTS_DIR = path.join(__dirname, '..', 'public', 'posts');
const OUT_FILE = path.join(__dirname, '..', 'src', 'posts', 'postsIndex.js');

function readFrontmatter(content) {
  const fm = content.match(/^---\n([\s\S]*?)\n---\n?/);
  if (!fm) return {};
  try {
    return yaml.load(fm[1]) || {};
  } catch (e) {
    console.error('Failed to parse frontmatter for a post:', e.message);
    return {};
  }
}

function buildIndex() {
  if (!fs.existsSync(POSTS_DIR)) {
    console.warn('No posts directory found at', POSTS_DIR);
    fs.writeFileSync(OUT_FILE, 'const posts = [];\n\nexport default posts;\n');
    return;
  }

  const files = fs.readdirSync(POSTS_DIR).filter(f => f.endsWith('.md'));
  const posts = files.map(fname => {
    const full = path.join(POSTS_DIR, fname);
    const raw = fs.readFileSync(full, 'utf8');
    const fm = readFrontmatter(raw);
    const slug = (fm.slug || fname.replace(/\.md$/, '')).trim();
    const title = fm.title || slug.replace(/[-_]/g, ' ');
    const description = fm.excerpt || fm.description || '';
    const date = fm.date || '';
    return { slug, title, description, date, url: `/blogs/${slug}` };
  });

  // Deduplicate by slug: prefer the post with a date or the newest date when duplicates exist
  const bySlug = {};
  for (const p of posts) {
    if (!bySlug[p.slug]) {
      bySlug[p.slug] = p;
      continue;
    }
    const existing = bySlug[p.slug];
    // If one has a date and the other doesn't, prefer the dated one.
    if (p.date && !existing.date) {
      bySlug[p.slug] = p;
      continue;
    }
    if (!p.date && existing.date) continue;
    // If both have dates, keep the newest.
    if (p.date && existing.date) {
      if (new Date(p.date) > new Date(existing.date)) {
        bySlug[p.slug] = p;
      }
      continue;
    }
    // Fallback: keep whichever has a longer description/title (heuristic)
    if ((p.description || '').length > (existing.description || '').length) {
      bySlug[p.slug] = p;
    }
  }

  const uniquePosts = Object.values(bySlug);

  // sort by date desc when date present
  uniquePosts.sort((a, b) => {
    if (a.date && b.date) return new Date(b.date) - new Date(a.date);
    if (a.date) return -1;
    if (b.date) return 1;
    return a.title.localeCompare(b.title);
  });

  const out = `// Auto-generated by scripts/generatePostsIndex.js - do not edit by hand\n` +
    `// Run: npm run generate-posts\n\n` +
    `const posts = ${JSON.stringify(uniquePosts, null, 2)};\n\nexport default posts;\n`;

  fs.mkdirSync(path.dirname(OUT_FILE), { recursive: true });
  fs.writeFileSync(OUT_FILE, out, 'utf8');
  console.log('Wrote', OUT_FILE, 'with', uniquePosts.length, 'posts');
}

buildIndex();
